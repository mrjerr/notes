Принципы SOLID
=

## Принцип единственной ответственности (The Single Responsibility Principle)
    Интерфейс или класс, при разработке имеет одну ответсвенность
При изменении требований, производится изменение ответсвенностей, распределённых между классами.

### Примеры:
#### Не соответсвует принципу единственной ответственности
    Сущность Повар и Клиент.
    Клиент делать заказ, Повар получает заказ, выполняет, доставляет Клиенту
#### Соответсвует:
    Сущность Повар, Официант, Клиент
    Клиент делать заказ у Официанта, передает Повару, Повар выполняет, Официант - Клиенту


## Принцип открытости/закрытости (The Open Closed Principle)
    Программные сущности(классы, модули, функции) должны быть открыты для расширения, но закрыты для модификации

Согласно этому принципу, старый код не редактируется, а пишется все время новый.
- Поведение любой сущности может быть расширено путем создания новых типов сущностей и наследованием
- В результате расширения поведения не должны вноситься изменения в код в котором используются эти сущности

#### Пример:
    При появлении Вип Клиента, который наследуется от Клиента, правильно создать ВипПовара, а не менять код Повара.

## Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)
    объекты в программе должны быть заменяемыми на объекты их подтипов без изменения правильности выполнения программы
Все процессы которые работают с объектами одного класса, должны точно так же работать с объектом другого класа который от него наследовался. Не нужно наследоваться если потомок будет создавать объекты другого типа, которому не свойственны атрибуты и функции родителя или они существенно отличаются.

#### Пример:
    ВипПовар должен иметь возможность обработать заказ как от Клиента так и от ВипКлиента. ПоварЗаготовки не должен наследоваться от Повара, потому что выполняет специфические задачи, которые свойсвенные только ему.


## Принцип разделения интерфейса (The Interface Segregation Principle)
    много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения

Много интерфейсов с минимумом методов, более специфических - лучше одного или нескольких интерфейсов, с большим количеством методов, всеохватывающих.

#### Пример:
    Кухня и один интерфейс для Повара и Посудомойщика
    Кухня и два интерфейса один для Повара и второй для Посудомойщика


## Принцип инверсии зависимостей (The Dependency Inversion Principle)
    Зависимость на Абстракциях. Нет зависимости на что-то конкретное.
Модули высокого уровня не должны зависить от модулей низкого уровня напрямую. Оба типа модулей должны зависить от абстракций. Зависимости должны стоиться относительно абстракций, а не деталей.

#### Пример:
    Повар может напрямую зависить от Кухни
    А может зависеть от интерфейса Кухонная плита, которая зависит от кухни
Это позволит в будущем иметь две кухни или менять на другую Кухню, от которых  будет зависеть интерфейс Кухонная Плита
