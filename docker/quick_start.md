Docker Quick Start
=
## Команды
### Images
 - **docker images** - список образов(image) на локальной машине
 - **docker search centos** - поиск по слову centos в dockerhub
 - **docker pull nginx:1.13.5** - получить(скачать) образ nginx версии 1.13.5
 - **docker inspect nginx:1.13.5** - выводит информацию о конкретном образе в формате json
 - **docker rmi nginx:1.13.5** - удалить указанный образ
### Containers
#### Docker run
```
-i интерактивно
-t создается tty # эта опция используется совместно с -i
--rm после остановки удалить контейнер
--name=SomeName присвоить контейнеру имя SomeName
```
 - **docker run hello-world** - создать и запустить контейнер из образа hello-world
в этом случае контейнер выведет информацию и завершит работу. Если несколько раз ввести эту комманду, то у нас создадуться несколько контейнеров. Именно этот котнейнер(hello-world) не работает в фоне, он после выполнения завершает работу и  занимает какое то место в системе и можно найти в списке контейнеров
 - **docker run \-\-name=web_srv -d nginx** - создать и запустить в фоне контейнер nginx с именем web_srv 
___
#### Docker attach
  - **docker attach <container_id>** - подключиться к контейнеру который выполняется
 Если контейнер выполняется в режиме демона(**docker run nginx**), то мы может подключиться к процессу, и если нажать Ctrl+C  то котнейнер завершит свою работу
 - **docker exec -it <container_id> /bin/bash** - подключаемся к контейнеру по id, в случае отключени от контейнера он продолжит работу
___
 - **docker ps**  - показать список работающих контейнеров
 - **docker ps -a**  - показать список всех существующих контейнеров
 - **docker start <container_id>** - запустить уже созданный контейнер
 - **docker stop <container_id>** - остановить выполняющийся контейнер
 - **docker inspect <container_id>** - выводит информацию о контейнере в формате json
 - **docker rm <container_id1> <container_id2>** - удалить один или несколько контейнеров

### Ports
 - **docker run -d -P nginx** - пробрасывает 80-й порт контейнера на любой незанятый случайный порт хоста на всех интерфейсах
 - **docker run -d -p 127.0.0.1:8181:80 nginx** - пробрасывает 80-й порт контейнера на порт 8181 на интерфейсе 127.0.0.1 хоста
 - **docker port <container_id>** - выводит информацию куда какой порт проброшен 
### Map dirs
 - **docker run -d -P -v /home/user/www:/usr/share/nginx/html nginx** - запустить контейнер и подключить директорию из хостовой машины в контейнер
 
## Dockerfile
 - **FROM debian:stable** - базовый образ debian:stable
 - **MAINTANER user <some@mail.com>** - информация о создателе
 - **RUN apt-get update && apt-get upgrade -y && apt-get install nginx -y**
 Каждая команда RUN создает отдельный слой,что бы было меньше слоев комманды группируются.
 Команда RUN выполняет инструкции на этапе сборки (build) контейнера

 - **ENV MYVALUE my-value-text** - опция ENV добавляет в окружение контейнера указанную переменную и значение для нее
 
 - **EXPOSE 80** - открывает порт 80 контейнера, для проброса на хост или взаимодейтсвия в пределах внутреней сети docker
 
 - **CMD ["nginx", "-g", "daemon off;"]** - Список с командой и аргументами выполняется при запуске контейнера. Этот набор параметров запустит установленный nginx при старте контейнера.
Если при запуске контейнера указать свою команду, например **(docker run -it myimage /bin/bash)** то указанная коман`да из секции **CMD** не будет выполняться, а выполниться то что указано явно.

Вариант запустить контейнер в фоне и подключиться к нему использовав команду **exec**. В таком случае выполниться CMD команды и потом запустить дополнительно нужные команды
```
docker run -d myimage
docker exec -it <conteiner_id> /bin/bash
```
___
**cat Dockerfile**
```
FROM debian:stable

MAINTANER user <some@mail.com>

RUN apt-get update && apt-get upgrade -y && apt-get install nginx -y

ENV MYVALUE my-value-text

EXPOSE 80
EXPOSE 22

CMD ["nginx", "-g", "daemon off;"]
```
Создаем образ под именем myuser/myimage, точка в конце указывает что Dockerfile нужно искать в текущей директории
```
docker build -t myuser/myimage .
```
